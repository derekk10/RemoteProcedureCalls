In my implementation of RPC I transferred data to the server by packing all of it into one buffer. I packed all information into a single buffer by using memcpy() and making sure to keep track of where to store different parts of the data in the buffer to prevent overwriting of data in the buffer. I created a helper function that would loop using send() until there were no bytes left to send to make sure all of the data was sent. I made a similar helper function to receive all bytes that are sent. These helper functions were implemented on both the client and server side to communicate with each other. I used these helper functions to send and receive most data types like ssize_t, size_t, off_t, and chars. In addition, I implemented a separate function for receiving ints on the server side since my implementation required the server to receive int type data (file descriptors, opcode, very frequently. 
For other data types like empty buffers that are written into as a side effect of certain system calls like write(), I did not send the buffer to the server side since those buffers do not share the same address space; instead, I created a buffer on both the client side and server side independently, and wrote into those buffers on both sides. Additionally, to deal with sending strings/character arrays which do not necessarily have a constant size in terms of bytes, I made sure to send the number of bytes to read before sending the string. I did this so that each respective side would have the information on how many bytes to read for a given string.
On a higher level, the way that I made the client side emulate the system calls was by initially sending necessary arguments to the server side. Once data is sent to the server, the server side executes the system call and sends the return value or other information like error number in the case of an error. 	
For implementing the serialization protocol for the functions that use the type dirtreenode (getdirtree), I used a similar design. I first sent the arguments in getdirtree to the server side so that getdirtree would be executed on the server. I then wrote a recursive helper function that would pack the tree into an array to be sent to the client and another recursive function that would unpack the array and reconstruct it into a tree. 
Another important part of the RPC design was dealing with passing file descriptors between client and server. Since the client and server may have different file descriptors, it was necessary to decrement the file descriptor on the server side by a sufficiently large number when receiving a file descriptor and incrementing the file descriptor by the same amount when sending the file descriptor back to the client. This was necessary because it prevented file descriptors from colliding with each other. 
Additionally, before initially sending information to the server side, I made sure to specify an opcode for each function that I implemented so that the server side would know which system call to execute. For error handling, depending on the execution of certain functions on the server side, I made sure to case on when the function returned an error message. If the return value indicated an error, I made sure to pass a flag (-1) to the client side followed by the errno. The flag allowed the client side to know that there was an error on the server and to expect the errno. On the client side, I cased on whether I received a -1 flag to know what kind of data that I was expecting to receive. 
